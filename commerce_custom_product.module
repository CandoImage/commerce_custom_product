<?php
/**
 * @file
 * Adds features to support the creation of customizable products.
 */

/**
 * Implements hook_menu().
 */
function commerce_custom_product_menu() {
  $items = array();

  $items['admin/commerce/config/line-items/add-product-line-item-type'] = array(
    'title' => 'Add a product line item type',
    'description' => 'Create a new customizable product line item type.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'commerce_custom_product_line_item_type_form',
      array('type' => '', 'name' => ''),
    ),
    'access arguments' => array('administer line item types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/commerce_custom_product.admin.inc',
  );

  // Add delete links for custom product line item types that can be deleted.
  foreach (commerce_custom_product_commerce_line_item_type_info() as $type => $line_item_type) {
    // Convert underscores to hyphens for the menu item argument.
    $type_arg = strtr($type, '_', '-');

    $items['admin/commerce/config/line-items/' . $type_arg . '/edit'] = array(
      'title' => 'Edit',
      'description' => 'Edit the custom product line item type.',
      'page callback' => 'commerce_custom_product_line_item_type_edit',
      'page arguments' => array($type),
      'access arguments' => array('administer line item types'),
      'type' => MENU_LOCAL_TASK,
      'context' => MENU_CONTEXT_INLINE,
      'weight' => 5,
      'file' => 'includes/commerce_custom_product.admin.inc',
    );

    $items['admin/commerce/config/line-items/' . $type_arg . '/delete'] = array(
      'title' => 'Delete',
      'description' => 'Delete the custom product line item type.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('commerce_custom_product_line_item_type_delete_form', $type),
      'access callback' => 'commerce_custom_product_line_item_type_delete_access',
      'access arguments' => array($type),
      'type' => MENU_LOCAL_TASK,
      'context' => MENU_CONTEXT_INLINE,
      'weight' => 10,
      'file' => 'includes/commerce_custom_product.admin.inc',
    );
  }

  return $items;
}

/**
 * Determines access to a delete form for the given line item type.
 */
function commerce_custom_product_line_item_type_delete_access($type) {
  // Load the line item type.
  $line_item_type = commerce_line_item_type_load($type);

  // Look for any line items of this type.
  $query = new EntityFieldQuery();

  $query
    ->entityCondition('entity_type', 'commerce_line_item', '=')
    ->entityCondition('bundle', $type, '=')
    ->count();

  // If we found at least one, return FALSE to prevent deletion of this line
  // item type.
  if ($query->execute() > 0) {
    return FALSE;
  }

  return user_access('administer line item types');
}

/**
 * Implements hook_help().
 */
function commerce_custom_product_help($path, $arg) {
  if ($path == 'admin/commerce/config/line-items') {
    return '<p>' . t('Add as many product line item types as you need to support the types of customizable products on your site. You must then change the Add to Cart form display formatter settings of a product reference field to use the new line item type. Any fields attached to the line item type marked to appear on the Add to Cart form will then appear when that form is rendered.') . '</p><p>' . t('Once a line item has been saved for the custom line item type (such as a product being added to the cart), the line item type can no longer be deleted unless you first delete all related line items.') . '</p>';
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * Adds the customizing review view mode to the commerce line item entity type.
 */
function commerce_custom_product_entity_info_alter(&$entity_info) {
  if (isset($entity_info['commerce_line_item']['view modes'])) {
    $entity_info['commerce_line_item']['view modes']['customizing_review'] = array(
      'label' => t('Customizing Review'),
      'custom settings' => TRUE,
    );
  }
}

/**
 * Implements hook_views_api().
 */
function commerce_custom_product_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_custom_product') . '/includes/views',
  );
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function commerce_custom_product_commerce_line_item_type_info() {
  $line_item_types = array();

  // Look for product line item types currently defined in the database.
  $db_types = commerce_custom_product_line_item_types();

  if (!empty($db_types)) {
    foreach ($db_types as $type => $line_item_type) {
      $line_item_types[$type] = array(
        'name' => check_plain($line_item_type['name']),
        'description' => t('A customizable product line item type.'),
        'product' => FALSE,
        'add_form_submit_value' => t('Add product'),
        'base' => 'commerce_product_line_item',
        'callbacks' => array(
          'configuration' => 'commerce_custom_product_line_item_configuration',
        ),
      );
    }
  }

  return $line_item_types;
}

/**
 * Ensure extra line item contains the back-reference entity reference field.
 *
 * @param array $line_item_type
 *   The info array of the line item type being configured.
 */
function commerce_custom_product_line_item_configuration($line_item_type) {
  commerce_product_line_item_configuration($line_item_type);
  $type = $line_item_type['type'];

  // Add back-reference field.
  $field_name = 'commerce_parent_line_item';
  commerce_activate_field($field_name);
  field_cache_clear();

  $field = field_info_field($field_name);
  $instance = field_info_instance('commerce_line_item', $field_name, $type);

  if (empty($field)) {
    $field = array(
      'field_name' => $field_name,
      'type' => 'entityreference',
      'cardinality' => 1,
      'settings' => array(
        'target_type' => 'commerce_line_item',
      ),
      'translatable' => FALSE,
      'locked' => TRUE,
    );
    field_create_field($field);
  }

  if (empty($instance)) {
    $instance = array(
      'field_name' => $field_name,
      'entity_type' => 'commerce_line_item',
      'bundle' => $type,
      'label' => t('Parent line item'),
      'required' => FALSE,
      'settings' => array(),

      'widget' => array(
        'type' => 'entityreference_autocomplete',
        'weight' => 0,
      ),

      'display' => array(
        'display' => array(
          'label' => 'hidden',
          'weight' => 0,
        ),
      ),
    );
    field_create_instance($instance);
  }

}

/**
 * Returns an array of all available customizable product line item types.
 */
function commerce_custom_product_line_item_types() {
  return db_query('SELECT * FROM {commerce_product_line_item_type}')->fetchAllAssoc('type', PDO::FETCH_ASSOC);
}

/**
 * Saves a customizable product line item type.
 *
 * @param string $line_item_type
 *   The full line item type info array to save.
 * @param bool $configure
 *   Boolean indicating whether or not line item type configuration should be
 *   performed in the event of a new line item type being saved.
 * @param bool $skip_rebuild
 *   Boolean indicating whether or not this save should result in the menu being
 *   rebuilt; defaults to FALSE. This is useful when you intend to perform many
 *   saves at once, as menu rebuilding is very costly to performance.
 *
 * @return FALSE|SAVED_NEW|SAVED_UPDATED
 *   The return value of the call to drupal_write_record() to save the line item
 *   type, either FALSE on failure or SAVED_NEW or SAVED_UPDATED indicating the
 *   type of query performed to save the line item type.
 */
function commerce_custom_product_line_item_type_save($line_item_type, $configure = TRUE, $skip_rebuild = FALSE) {
  $op = drupal_write_record('commerce_product_line_item_type', $line_item_type, commerce_line_item_type_load($line_item_type['type']) ? 'type' : array());
  commerce_line_item_types_reset();

  if ($op == SAVED_NEW) {
    // Notify the field API that a new bundle has been created.
    field_attach_create_bundle('commerce_line_item', $line_item_type['type']);

    // Load the full line item type array.
    $line_item_type = commerce_line_item_type_load($line_item_type['type']);

    // Configure the new line item type with default fields.
    if ($configure) {
      commerce_line_item_configure_line_item_type($line_item_type);
    }

    // Notify other modules that a new line item type has been created.
    module_invoke_all('commerce_custom_product_line_item_type_insert', $line_item_type, $skip_rebuild);
  }
  elseif ($op == SAVED_UPDATED) {
    // Notify other modules that an existing line item type has been updated.
    module_invoke_all('commerce_custom_product_line_item_type_update', $line_item_type, $skip_rebuild);
  }

  if (!$skip_rebuild) {
    variable_set('menu_rebuild_needed', TRUE);
  }

  return $op;
}

/**
 * Deletes a customizable product line item type.
 *
 * @param string $type
 *   The machine-name of the line item type to delete.
 */
function commerce_custom_product_line_item_type_delete($type) {
  // Load the full line item type.
  $line_item_type = commerce_line_item_type_load($type);

  db_delete('commerce_product_line_item_type')
    ->condition('type', $type)
    ->execute();

  commerce_line_item_types_reset();

  // Notify other modules that this bundle / line item type has been deleted.
  field_attach_delete_bundle('commerce_line_item', $line_item_type['type']);
  module_invoke_all('commerce_custom_product_line_item_type_delete', $line_item_type);

  variable_set('menu_rebuild_needed', TRUE);
}

/**
 * Implements hook_field_info().
 */
function commerce_custom_product_field_info() {
  return array(
    'commerce_custom_product_line_item_type_reference' => array(
      'label' => t('Line item type reference'),
      'description' => t('This field stores the ID of a related line item type.'),
      'settings' => array(
        'entity_translation_sync' => array(
          'target_id',
          'use_multi',
        ),
      ),
      'instance_settings' => array(
        'entity_translation_sync' => array(
          'target_id',
          'use_multi',
        ),
      ),
      'default_widget' => 'commerce_custom_product_line_item_type_reference_select',
      'default_formatter' => NULL,
    ),
  );
}

/**
 * Implements hook_field_validate().
 */
function commerce_custom_product_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  if ($field['type'] == 'commerce_custom_product_line_item_type_reference') {
    foreach ($items as $delta => $item) {
      if (!empty($item['target_id'])) {
        $type = commerce_line_item_type_load($item['target_id']);
        if (!$type || $type['product']) {
          $errors[$field['field_name']][$langcode][$delta][] = array(
            'error' => 'commerce_custom_product_line_item_type_reference_invalid',
            'message' => t('%name: Invalid line item type referenced.', array('%name' => $instance['label'])),
          );
        }
      }
    }
  }
}

/**
 * Implements hook_field_widget_info().
 */
function commerce_custom_product_field_widget_info() {
  $widgets = array();

  $widgets['commerce_custom_product_line_item_type_reference_select'] = array(
    'label' => t('Select list'),
    'description' => t('Select referencable line item type from a drop-down.'),
    'field types' => array('commerce_custom_product_line_item_type_reference'),
    'settings' => array(),
    'behaviors' => array(
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );

  return $widgets;
}

/**
 * Implements hook_field_widget_form().
 */
function commerce_custom_product_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  if (isset($form_state['triggering_element']['#field_name']) && isset($form_state['triggering_element']['#langcode']) && isset($form_state['triggering_element']['#delta'])) {
    if ($form_state['triggering_element']['#field_name'] == $field['field_name'] && $form_state['triggering_element']['#langcode'] == $langcode && $form_state['triggering_element']['#delta'] == $delta) {
      return FALSE;
    }
  }
  // Define the autocomplete textfield for products.
  if ($instance['widget']['type'] == 'commerce_custom_product_line_item_type_reference_select') {
    $line_items_types = array_filter(
      commerce_line_item_types(),
      function ($item) {
        return !$item['product'];
      }
    );

    $options = array(NULL => '- ' . t('None') . ' -');
    foreach ($line_items_types as $line_items_type) {
      $options[$line_items_type['type']] = $line_items_type['name'];
    }

    $element = $element + array(
      'target_id' => array(
        '#type' => 'select',
        '#default_value' => isset($items[$delta]['target_id']) ? $items[$delta]['target_id'] : NULL,
        '#options' => $options,
        '#description' => ' (' . t('all languages') . ')',
      ),
      'use_multi' => array(
        '#type' => 'checkbox',
        '#title' => t('One line item per product item'),
        '#default_value' => isset($items[$delta]['use_multi']) ? $items[$delta]['use_multi'] : 0,
        '#description' => '(' . t('all languages') . ')',
      ),
      'label' => array(
        '#type' => 'textfield',
        '#title' => t('Customization label'),
        '#default_value' => isset($items[$delta]['label']) ? $items[$delta]['label'] : '',
      ),
      'description' => array(
        '#type' => 'textarea',
        '#title' => t('Customization description'),
        '#default_value' => isset($items[$delta]['description']) ? $items[$delta]['description'] : '',
      ),
    );

    if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED && isset($items[$delta])) {
      $element['remove_button'] = array(
        '#type' => 'button',
        '#value' => t('Remove'),
        '#name' => drupal_html_class('remove-button-' . $field['field_name'] . '-' . $langcode . '-' . $delta),
        '#weight' => 10,
        '#submit' => 'commerce_custom_product_field_widget_form_ajax',
        '#ajax' => array(
          'callback' => 'commerce_custom_product_field_widget_form_ajax',
        ),
        '#limit_validation_errors' => array(),
        '#field_name' => $field['field_name'],
        '#langcode' => $langcode,
        '#delta' => $delta,
        '#remove_button' => TRUE,
      );
    }
    return $element;
  }
}

/**
 * Ajax handler for the field widget form.
 */
function commerce_custom_product_field_widget_form_ajax($form, &$form_state) {
    $parents = $form_state['triggering_element']['#array_parents'];
    array_pop($parents);
    array_pop($parents);
    array_pop($parents);
    $element = drupal_array_get_nested_value($form, $parents);

    $wrapper = '.form-wrapper.' . drupal_html_class('field-name-' . $form_state['triggering_element']['#field_name']);

    return array(
      '#type' => 'ajax',
      '#commands' => array(
        ajax_command_replace($wrapper, render($element)),
      ),
    );
}

/**
 * Implements hook_field_is_empty().
 */
function commerce_custom_product_field_is_empty($item, $field) {
  return empty($item['target_id']);
}

/**
 * Implements hook_commerce_cart_order_refresh().
 *
 * Takes care of managing the extra items on an order.
 * - Remove orphaned extra line items.
 * - Remove use_multi extra line items that are to many.
 * - Adds missing extra line items according to the parent line item quantity.
 */
function commerce_custom_product_commerce_cart_order_refresh($order_wrapper) {
  $order = $order_wrapper->value();
  // Collect all line items. And group extra line items on their parent.
  $line_item_ids = array();
  $extra_line_items = array();
  $extra_line_items_to_delete = array();
  $extra_line_items_count = array();
  $parent_line_items = array();
  foreach ($order_wrapper->commerce_line_items as $i => $line_item_wrapper) {
    $line_item = $line_item_wrapper->value();
    $line_item_id = $line_item_wrapper->getIdentifier();
    $line_item_ids[$line_item_id] = $line_item_id;
    // If this line item has a commerce_parent_line_item field and the context
    // data tell us that it actually has a parent analyze it.
    if (isset($line_item_wrapper->commerce_parent_line_item) && isset($line_item->data['context']['commerce_custom_product'])) {
      $parent_line_item_id = $line_item_wrapper->commerce_parent_line_item->raw();
      $extra_line_items[$parent_line_item_id][$i] = $line_item_id;
      if (isset($line_item->data['context']['commerce_custom_product']) && $line_item_wrapper->commerce_parent_line_item->value()) {
        $customizing_type_delta = $line_item->data['context']['commerce_custom_product']['delta'];
        if (!isset($extra_line_items_count[$parent_line_item_id][$customizing_type_delta])) {
          $extra_line_items_count[$parent_line_item_id][$customizing_type_delta] = 0;
        }
        $extra_line_items_count[$parent_line_item_id][$customizing_type_delta]++;

        // Ensure use_multi line items match the parent line item count.
        if ($line_item_wrapper->commerce_parent_line_item->quantity->value() < $extra_line_items_count[$parent_line_item_id][$customizing_type_delta]) {
          $extra_line_items_to_delete[] = $line_item_id;
          $order_wrapper->commerce_line_items->offsetUnset($i);
        }
      }
    }
    elseif (isset($line_item->data['context']['commerce_custom_product'])) {
      $parent_line_items[$line_item_id] = $line_item;
    }
  }
  // Now filter all extra line items whose parent is gone.
  foreach (array_diff_key($extra_line_items, $line_item_ids) as $extra_line_items) {
    $extra_line_items_to_delete += $extra_line_items;
  }

  // Delete orphaned extra line items and remove references from order.
  if (!empty($extra_line_items_to_delete)) {
    commerce_line_item_delete_multiple($extra_line_items_to_delete);

    // Now remove the line item references. As we store the index in the field
    // above we can use array_diff_key() again.
    $order->commerce_parent_line_item[LANGUAGE_NONE] = array_values(array_diff_key($order->commerce_line_items[LANGUAGE_NONE], $extra_line_items_to_delete));
  }

  // Check if there are missing extra line items and if so add them.
  if (!empty($parent_line_items)) {
    foreach ($parent_line_items as $parent_line_item_id => $parent_line_item) {
      $customizing_context = $parent_line_item->data['context']['commerce_custom_product'];
      $settings_entity = entity_load_single($customizing_context['settings_entity']['entity_type'], $customizing_context['settings_entity']['id']);
      // If customizing types could be fetched iterate over all of them.
      if ($customizing_types = field_get_items($customizing_context['settings_entity']['entity_type'], $settings_entity, $customizing_context['settings']['extra_line_items_field'])) {
        foreach ($customizing_types as $type_delta => $type) {
          // If this customizing type us related to the parent line item
          // quantity set it accordingly - otherwise just use 1 as quantity.
          $quantity = (!empty($type['use_multi'])) ? $parent_line_item->quantity : 1;
          // If there aren't enough extra line items iterate over all missing
          // ones and add them.
          if ($extra_line_items_count[$parent_line_item_id][$type_delta] < $quantity ) {

            for ($i = $extra_line_items_count[$parent_line_item_id][$type_delta]; $i < $quantity; $i++) {
              $product_ids = commerce_cart_add_to_cart_form_product_ids($parent_line_item);
              $products = commerce_product_load_multiple($product_ids);
              $product = commerce_product_reference_default_product($products);
              // Build the line item context data.
              $line_item_data['context']['product_ids'] = array_keys($products);
              $line_item_data['context']['add_to_cart_combine'] = !empty($settings['combine']);
              $line_item_data['context']['show_single_product_attributes'] = !empty($settings['show_single_product_attributes']);
              $line_item_data['context']['use_multi'] = $type['use_multi'];
              $line_item_data['context']['extra_line_item_index'] = $i;
              $line_item_data['context']['commerce_custom_product'] = array_merge($customizing_context, array(
                'delta' => $type_delta,
              ));
              $line_item = commerce_custom_product_create_extra_line_item($type['target_id'], $parent_line_items[$parent_line_item_id], $order, $quantity, $line_item_data, $product);

              // If this is a new line item we need to add it to the order too.
              if (commerce_line_item_save($line_item) == SAVED_NEW) {
                $order_wrapper->commerce_line_items[] = $line_item;
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Returns a boolean that indicates if this order has customized products.
 *
 * @param object $order
 *   The commerce order to check for customized products.
 *
 * @return bool
 *   Keyed by the parent line item id.
 */
function commerce_custom_product_order_has_customized_products($order = NULL) {
  if (empty($order)) {
    $order = commerce_cart_order_load($GLOBALS['user']->uid);
  }
  // Check if we have an usable order.
  if (!$order) {
    return FALSE;
  }
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  // Collect all the extra line items and group them by parent line item and
  // type delta.
  /** @var EntityDrupalWrapper $line_item */
  foreach ($order_wrapper->commerce_line_items as $line_item) {
    if (isset($line_item->commerce_parent_line_item) && !is_null($line_item->commerce_parent_line_item->value())) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Returns a list of existing extra line items in an order.
 *
 * Takes care to bundle the fields of the same type delta.
 *
 * @param object $order
 *   The commerce order to check for extra line items.
 *
 * @return array
 *   Keyed by the parent line item id.
 */
function commerce_custom_product_order_get_existing_extra_line_items($order = NULL) {
  if (empty($order)) {
    $order = commerce_cart_order_load($GLOBALS['user']->uid);
  }
  // Check if we have an usable order.
  if (!$order) {
    return array();
  }
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $extra_line_items = array();
  // Collect all the extra line items and group them by parent line item and
  // type delta.
  /** @var EntityDrupalWrapper $line_item */
  foreach ($order_wrapper->commerce_line_items as $line_item) {
    if (isset($line_item->commerce_parent_line_item) && !is_null($line_item->commerce_parent_line_item->value())) {
      // Prepare array structure.
      if (!isset($extra_line_items[$line_item->commerce_parent_line_item->raw()])) {
        $extra_line_items[$line_item->commerce_parent_line_item->raw()] = array(
          'parent_line_item' => $line_item->commerce_parent_line_item->value(),
          'extra_line_items' => array(),
        );
      }
      $line_item_raw = $line_item->value();
      $extra_line_items[$line_item->commerce_parent_line_item->raw()]['extra_line_items'][] = $line_item_raw;
    }
  }
  // Now do all the sorting for the found extra line items.
  foreach ($extra_line_items as $parent_line_item_id => $extra_line_item_data) {
    // Set the sorted and reduced array as result.
    $extra_line_items[$parent_line_item_id]['extra_line_items'] = array_values(commerce_custom_product_order_sort_existing_extra_line_items($extra_line_items[$parent_line_item_id]['extra_line_items']));
  }
  return $extra_line_items;
}

/**
 * Orders an array of extra line items accoring to their delta type and weight.
 *
 * @param array $extra_line_items
 *   List of extra line item objects.
 *
 * @return array
 *   Ordered list of extra line item objects.
 */
function commerce_custom_product_order_sort_existing_extra_line_items($extra_line_items) {
  // Use custom sorting callback to order line items.
  uasort($extra_line_items, function($a, $b){
    if (!isset($a->data['context']['commerce_custom_product']['delta'])) {
      return -1;
    }
    if (!isset($b->data['context']['commerce_custom_product']['delta'])) {
      return 1;
    }
    // If we're in the same type delta order the extra line items by their
    // order. Otherwise we'll pass this and order by type delta. That way the
    // extra line items are grouped by customizing type.
    if ($a->data['context']['commerce_custom_product']['delta'] == $b->data['context']['commerce_custom_product']['delta']) {
      if (!isset($a->data['context']['extra_line_item_index']) || !isset($a->data['context']['extra_line_item_index'])) {
        return 0;
      }
      return ($a->data['context']['extra_line_item_index'] < $b->data['context']['extra_line_item_index']) ? -1 : 1;
    }
    return ($a->data['context']['commerce_custom_product']['delta'] < $b->data['context']['commerce_custom_product']['delta']) ? -1 : 1;
  });
  return $extra_line_items;
}

/**
 * Returns the customizing settings for a extra line item..
 *
 * @param object $extra_line_item
 *   An extra line item object.
 *
 * @return array|FALSE
 *   Customizing settings for this extra line item. FALSE if no settings were
 *   found.
 */
function commerce_custom_product_get_customizing_settings_from_line_item($extra_line_item) {
  // Check if the extra line item has a custom product context.
  if (isset($extra_line_item->data['context']['commerce_custom_product'])) {
    // Use the context to load the customizing settings.
    $customizing_context = $extra_line_item->data['context']['commerce_custom_product'];
    $settings_entity = entity_load_single($customizing_context['settings_entity']['entity_type'], $customizing_context['settings_entity']['id']);
    // Fetch the configuration from the related field.
    $customizing_types = field_get_items($customizing_context['settings_entity']['entity_type'], $settings_entity, $customizing_context['settings']['extra_line_items_field']);
    // If the delta exits return the configuration. Other
    if (isset($customizing_types[$customizing_context['delta']])) {
      $customizing_settings = $customizing_types[$customizing_context['delta']];
      // Add the delta to keep track of the "type".
      $customizing_settings['delta'] = $customizing_context['delta'];
      return $customizing_settings;
    }
  }
  return FALSE;
}

/**
 * Extract the field settings that apply to alter the add to cart form.
 *
 * @param string|array $view_mode
 *   The view mode either the name or definition array of it.
 * @param string $entity_type
 *   The entity type we deal with.
 * @param string $bundle
 *   The bundle of the entity type.
 *
 * @return array
 *   The array with the customization settings:
 *   - extra_line_items_field: The line items field to use.
 *   - skip_customization_on_add_to_cart: If customizing in the add to cart is
 *     skipped.
 */
function commerce_custom_product_get_field_customization_settings($view_mode, $entity_type, $bundle) {
  $customization_settings = array(
    'extra_line_items_field' => NULL,
    'skip_customization_on_add_to_cart' => FALSE,
  );
  // If the display information contains settings use them, otherwise it's the
  // name of a view mode.
  if (is_array($view_mode)) {
    if (isset($view_mode['settings']['extra_line_items_field'])) {
      $customization_settings['extra_line_items_field'] = $view_mode['settings']['extra_line_items_field'];
      $customization_settings['skip_customization_on_add_to_cart'] = !empty($view_mode['settings']['skip_customization_on_add_to_cart']);
    }
  }
  else {
    // Check field configuration and see which field is to be used as the source
    // for configuration.
    foreach (field_info_instances($entity_type, $bundle) as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['type'] == 'commerce_product_reference') {
        if (empty($instance['display'][$view_mode])) {
          $view_mode = 'default';
        }
        if ($instance['display'][$view_mode]['type'] == 'commerce_cart_add_to_cart_form') {
          $customization_settings['extra_line_items_field'] = $instance['display'][$view_mode]['settings']['extra_line_items_field'];
          $customization_settings['skip_customization_on_add_to_cart'] = !empty($instance['display'][$view_mode]['settings']['skip_customization_on_add_to_cart']);
        }
      }
    }
  }
  return $customization_settings;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Instead of displaying fields from one line item type it reads data from a
 * field and displays one or more line items.
 */
function commerce_custom_product_form_commerce_cart_add_to_cart_form_alter(&$form, &$form_state) {
  $entity = entity_load($form_state['context']['entity_type'], array($form_state['context']['entity_id']));
  $entity = reset($entity);
  $view_mode = $form_state['context']['display'];
  $entity_info = entity_get_info($form_state['context']['entity_type']);
  $bundle_key = $entity_info['entity keys']['bundle'];

  // Fetch the settings for the customization form.
  $customization_settings = commerce_custom_product_get_field_customization_settings($view_mode, $form_state['context']['entity_type'], $entity->{$bundle_key});

  // Add the customization settings to the context of the related product line
  // item. Used to ensure the consistency of the extra line items.
  $form_state['line_item']->data['context']['commerce_custom_product'] = array(
    'settings_entity' => array('entity_type' => $form_state['context']['entity_type']) + array_combine(array('id', 'vid', 'bundle'), entity_extract_ids($form_state['context']['entity_type'], $entity)),
    'settings' => $customization_settings,
  );

  // If configuration field was found and there are values on it add stuff to
  // the form.
  if ($customization_settings['extra_line_items_field'] && $types = field_get_items($form_state['context']['entity_type'], $entity, $customization_settings['extra_line_items_field'])) {
    if (!empty($form_state['input']['quantity'])) {
      $form['quantity']['#default_value'] = $form_state['input']['quantity'];
    }

    $form['quantity']['#ajax'] = array(
      'callback' => 'commerce_custom_product_quantity_js',
      'wrapper' => $form['#id'],
      'method' => 'replace',
    );

    $product_ids = commerce_cart_add_to_cart_form_product_ids($form_state['line_item']);
    $products = commerce_product_load_multiple($product_ids);

    $form['extra_line_items_fields'] = array(
      '#type' => 'container',
      '#parents' => array('extra_line_items_fields'),
      '#weight' => 11,
      '#tree' => TRUE,
    );
    $form_state['extra_line_items_fields'] = array();

    // Get existent extra line items of the current order.
    $existing_extra_line_item_data = commerce_custom_product_order_get_existing_extra_line_items();
    foreach ($existing_extra_line_item_data as $parent_line_item_id => $data) {
      $parent_product_ids = commerce_cart_add_to_cart_form_product_ids($data['parent_line_item']);
      if (!empty($data['parent_line_item']->data['context']['product_ids']) && $parent_product_ids == $product_ids) {
        $parent_line_item = $data['parent_line_item'];
        $existing_extra_line_items = $data['extra_line_items'];
      }
    }

    $uses_multi = FALSE;
    $has_existing_extra_line_items = array();
    $id = 0;
    $previous_extra_line_items = (isset($form_state['extra_line_items'])) ? $form_state['extra_line_items'] : array();
    $form_state['extra_line_items'] = array();
    foreach ($types as $delta => $type) {
      $line_item_count = 0;
      $uses_multi = $uses_multi || $type['use_multi'];
      do {
        // Try to find the corresponding line item in old form_state
        foreach ($previous_extra_line_items as $extra_line_item) {
          if (isset($extra_line_item->data['context']['extra_line_item_index']) && $extra_line_item->data['context']['extra_line_item_index'] == $id && $extra_line_item->type == $type['target_id']) {
            $form_state['extra_line_items'][$id] = $extra_line_item;
            $line_item = $extra_line_item;
            break;
          }
        }
        // If line item was not found in previous form_state.
        if (empty($form_state['extra_line_items'][$id])) {
          $line_item = FALSE;
          // If this isn't quantity based try to detect existing line item.
          if (empty($type['use_multi']) && isset($existing_extra_line_items)) {
            foreach ($existing_extra_line_items as $extra_line_item) {
              if (isset($extra_line_item->data['context']['use_multi']) && $extra_line_item->data['context']['use_multi'] == $type['use_multi'] && $extra_line_item->type == $type['target_id']) {
                $line_item = $extra_line_item;
                $has_existing_extra_line_items = TRUE;
                break;
              }
            }
          }
          // Create new line item if non could be detected.
          if (!$line_item) {
            $line_item = commerce_product_line_item_new(commerce_product_reference_default_product($products), 1, 0, array(), $type['target_id']);
            $line_item->data['context']['product_ids'] = array_keys($products);
            $line_item->data['context']['add_to_cart_combine'] = !empty($settings['combine']);
            $line_item->data['context']['show_single_product_attributes'] = !empty($settings['show_single_product_attributes']);
            $line_item->data['context']['use_multi'] = $type['use_multi'];
            $line_item->data['context']['extra_line_item_index'] = $id;
          }
          $line_item->data['context']['commerce_custom_product'] = $form_state['line_item']->data['context']['commerce_custom_product'] + array(
            'delta' => $delta,
          );
          $form_state['extra_line_items'][$id] = $line_item;
        }

        // If customization in the add to cart form is disabled just ensure the
        // extra line items are prepared.
        if (!$customization_settings['skip_customization_on_add_to_cart']) {
          $form['extra_line_items_fields'][$id] = commerce_custom_product_extra_line_item_form_element($line_item, $form_state, array_merge($form['extra_line_items_fields']['#parents'], array($id)));
        }
        $id++;
        $line_item_count++;
        // TODO - We might need to read quantity from a different source.
      } while ($type['use_multi'] && $line_item_count < $form['quantity']['#default_value']);
    }

    // If this is an existing line item that can be updated adjust some of the
    // form elements.
    if ($has_existing_extra_line_items && !$customization_settings['skip_customization_on_add_to_cart']) {
      $form['submit']['#name'] = 'update';
      $form_state['line_item']->line_item_id = $parent_line_item->line_item_id;

      // A full update is only possible if this hasn't multi items.
      if (!$uses_multi) {
        $form['submit']['#value'] = t('Upate Customization');
        $form['quantity']['#value'] = $parent_line_item->quantity;
        if ($form['quantity']['#datatype'] == 'integer') {
          $form['quantity']['#value'] = (int) $form['quantity']['#value'];
        }
      }
    }

    $form['#submit'][0] = 'commerce_custom_product_add_to_cart_form_submit';
  }
}

/**
 * Creates the customizing line item form element.
 *
 * @param object $line_item
 *   The customization line item.
 * @param array $form_state
 *   The form state.
 * @param NULL|array $form_parents
 *   If set this is used as parents array of the form element.
 *
 * @return array
 *   Customizing line item form element.
 */
function commerce_custom_product_extra_line_item_form_element($line_item, array &$form_state, $form_parents = NULL) {
  $element = array(
    '#type' => 'container',
  );
  // Add all line item fields to the form element.
  field_attach_form('commerce_line_item', $line_item, $element, $form_state);

  // Loop over the fields we just added and remove any that haven't been
  // marked for inclusion on this form.
  foreach (element_children($element) as $field_name) {
    if ($form_parents) {
      $element['#parents'] = $form_parents;
    }
    $info = field_info_instance('commerce_line_item', $field_name, $line_item->type);
    $element[$field_name]['#commerce_cart_settings'] = commerce_cart_field_instance_access_settings($info);

    if (empty($element[$field_name]['#commerce_cart_settings']['field_access'])) {
      $element[$field_name]['#access'] = FALSE;
    }
  }
  return $element;
}

/**
 * Form submit handler: add the selected product to the cart.
 *
 * @see commerce_cart_add_to_cart_form_submit()
 */
function commerce_custom_product_add_to_cart_form_submit($form, &$form_state) {
  if ($order = commerce_cart_order_load($form_state['values']['uid'])) {
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
    $line_items_count = count($order_wrapper->commerce_line_items);
  }
  $is_update = $form_state['triggering_element']['#name'] == 'update';

  // If this is an update of an existing line item increase the quantity.
  if (!empty($form_state['line_item']->line_item_id) && $is_update) {
    $parent_line_item = commerce_line_item_load($form_state['line_item']->line_item_id);
    $parent_line_item->quantity += $form_state['values']['quantity'];
    commerce_line_item_save($parent_line_item);
  }

  // Use default submit handler to add product line item.
  commerce_cart_add_to_cart_form_submit($form, $form_state);
  // Ensure the order wrapper is updated - the submit above seems to kill the
  // reference.
  $order = commerce_cart_order_load($form_state['values']['uid']);
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // If we still have same number of line items we combined new product into an
  // existing line item.
  $combined = empty($line_items_count) ? FALSE : $line_items_count == count($order_wrapper->commerce_line_items);

  // Collect line item ids. Needed to ensure we deal with really existing line
  // items later in processing.
  $line_item_ids = array();
  foreach ($order_wrapper->commerce_line_items as $line_item) {
    $line_item_ids[$line_item->getIdentifier()] = $line_item->getIdentifier();
  }

  // Add any additional line items.
  if (!empty($form_state['extra_line_items'])) {
    $product_id = $form_state['values']['product_id'];
    $update_order = FALSE;

    foreach ($form_state['extra_line_items'] as $id => $line_item) {
      // If the product was combined into an existing line item and we are not
      // adding multiple extra line items skip it.
      if ($combined && !$line_item->data['context']['use_multi'] && !$is_update) {
        break;
      }

      // Ensure non existing line items are re-created. We can't rely on the
      // data in the form state as they might are outdated by e.g. an action in
      // another tab. Thus we check that the line item id is in the current
      // order and if not handle it like a new one.
      if (!empty($line_item->line_item_id) && !isset($line_item_ids[$line_item->line_item_id])) {
        unset($line_item->line_item_id);
      }
      // If it's a new line item create it, otherwise update it.
      if (empty($line_item->line_item_id)) {
        $line_item = commerce_custom_product_create_extra_line_item($line_item->type, $form_state['line_item'], $order, $form_state['values']['quantity'], $line_item->data, $product_id);
      }
      else {
        // Update quantity.
        $line_item->quantity = (int) $form_state['values']['quantity'];
      }
      // Check if we've fields with values to set into the line items.
      if (!empty($form_state['values']['extra_line_items_fields'])) {
        // Remove line item field values the user didn't have access to modify.
        foreach ($form_state['values']['extra_line_items_fields'][$id] as $field_name => $value) {
          // Note that we're checking the Commerce Cart settings that we
          // inserted into this form element array back when we built the form.
          // This means a module wanting to alter a line item field widget to be
          // available must update both its form element's #access value and the
          // field_access value of the #commerce_cart_settings array.
          if (empty($form['extra_line_items_fields'][$id][$field_name]['#commerce_cart_settings']['field_access'])) {
            unset($form_state['values']['extra_line_items_fields'][$id][$field_name]);
          }
        }

        // Unset the line item field values array if it is now empty.
        if (empty($form_state['values']['extra_line_items_fields'][$id])) {
          unset($form_state['values']['extra_line_items_fields'][$id]);
        }

        // Add field data to the line item.
        field_attach_submit('commerce_line_item', $line_item, $form['extra_line_items_fields'][$id], $form_state);
      }
      // If this is a new line item we need to add it to the order too.
      if (commerce_line_item_save($line_item) == SAVED_NEW) {
        // Add new line item to the order.
        $order_wrapper->commerce_line_items[] = $line_item;
        $update_order = TRUE;
      }
    }

    if ($update_order) {
      // Use order wrapper to save to ensure consistency.
      $order_wrapper->save();
    }
  }
}

/**
 * Function to create extra line item object.
 *
 * Doesn't save the newly create line item object!
 *
 * @param string $line_item_type
 *   The line item type to create.
 * @param int $parent_line_item
 *   The id of the parent line item
 * @param object $order
 *   The commerce order this line item will belong to.
 * @param int $quantity
 *   The quantity value for the line item.
 * @param array $data
 *   The additional data for the line item - should contain the context
 *   information of the line item.
 * @param int $product_id
 *   The product id of the product related to this line item.
 *
 * @return object
 */
function commerce_custom_product_create_extra_line_item($line_item_type, $parent_line_item, $order, $quantity, $data, $product_id = NULL) {
  $line_item_types = commerce_line_item_types();
  // Use different approach to create product vs non-product line items.
  if (!empty($line_item_types[$line_item_type]['product'])) {
    $product = commerce_product_load($product_id);
    $line_item = commerce_product_line_item_new($product, $quantity, 0, $parent_line_item->data, $parent_line_item->type);
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  }
  else {
    // Create the new product line item of the same type.
    $line_item = entity_create('commerce_line_item', array(
      'type' => $line_item_type,
      'order_id' => $order->order_id,
      'data' => $data,
    ));
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    // Ensure standard field values are properly set.
    if (isset($line_item_wrapper->commerce_unit_price)) {
      // Total is set when saving.
      $line_item_wrapper->commerce_unit_price = commerce_price_wrapper_value($line_item_wrapper, 'commerce_unit_price', TRUE);
    }
    if (isset($line_item_wrapper->commerce_product)) {
      $line_item_wrapper->commerce_product = $product_id;
    }
  }
  // Maintain back-reference to the original product line item.
  $line_item_wrapper->commerce_parent_line_item = $parent_line_item->line_item_id;
  return $line_item;
}

/**
 * JS callback for quantity updates on "Add to cart" form.
 */
function commerce_custom_product_quantity_js($form, $form_state) {
  return $form;
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function commerce_custom_product_field_formatter_info_alter(&$info) {
  $info['commerce_cart_add_to_cart_form']['settings']['extra_line_items_field'] = NULL;
  $info['commerce_cart_add_to_cart_form']['settings']['skip_customization_on_add_to_cart'] = FALSE;
}

/**
 * Returns an array with a list of line item type / product reference fields.
 *
 * @param string $entity_type
 *   The entity type to check.
 * @param string|NULL $bundle
 *   The bundle to check.
 *
 * @return array
 *   List of line item type / product reference fields. The array is keyed by:
 *   - line_item_type_ref_fields: array of relevant line item type reference
 *     fields.
 *   - product_ref_fields: array of relevant product reference fields.
 */
function commerce_custom_product_get_field_options($entity_type, $bundle = NULL) {
  $cache = &drupal_static(__FUNCTION__, array());
  $cid = $entity_type . ':' . $bundle;
  if (isset($cache[$cid])) {
    return $cache[$cid];
  }

  $product_ref_fields = $line_item_type_ref_fields = array();
  $instances = field_info_instances($entity_type, $bundle);
  if (!$bundle) {
    $all_instances = array();
    foreach ($instances as $bundle_instances) {
      $all_instances += $bundle_instances;
    }
    $instances = $all_instances;
  }
  foreach ($instances as $instance) {
    $field = field_info_field($instance['field_name']);
    if ($field['type'] == 'commerce_custom_product_line_item_type_reference') {
      $line_item_type_ref_fields[$instance['field_name']] = $instance['label'];
    }
    elseif ($field['type'] == 'commerce_product_reference') {
      $product_ref_fields[$instance['field_name']] = $instance['field_name'];
    }
  }

  $cache[$cid] = array(
    'line_item_type_ref_fields' => $line_item_type_ref_fields,
    'product_ref_fields' => $product_ref_fields,
  );
  return $cache[$cid];
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_display_overview_form.
 *
 * Alters field display overview.
 */
function commerce_custom_product_form_field_ui_display_overview_form_alter(&$form, $form_state) {
  // Check if we have both product reference and line item type reference
  // fields.
  $instances = field_info_instances($form['#entity_type'], $form['#bundle']);
  $field_options = commerce_custom_product_get_field_options($form['#entity_type'], $form['#bundle']);

  if (!empty($field_options['line_item_type_ref_fields']) && !empty($field_options['product_ref_fields'])) {
    foreach ($field_options['product_ref_fields'] as $field_name) {
      $extra_line_items_field = NULL;
      if (isset($instances[$field_name]['display'][$form['#view_mode']]['settings']['extra_line_items_field'])) {
        $extra_line_items_field = $instances[$field_name]['display'][$form['#view_mode']]['settings']['extra_line_items_field'];
      }
      if (!empty($form_state['values']['fields'][$field_name]['settings_edit_form']['settings']['extra_line_items_field'])) {
        $extra_line_items_field = $form_state['values']['fields'][$field_name]['settings_edit_form']['settings']['extra_line_items_field'];
      }
      $skip_customization_on_add_to_cart = !empty($instances[$field_name]['display'][$form['#view_mode']]['settings']['skip_customization_on_add_to_cart']) || !empty($form_state['values']['fields'][$field_name]['settings_edit_form']['settings']['skip_customization_on_add_to_cart']);

      // Update field formatter settings summary with info about extra line
      // items field.
      if (!empty($form['fields'][$field_name]['settings_summary']['#markup'])) {
        $items = explode('<br />', $form['fields'][$field_name]['settings_summary']['#markup']);
        $last = array_pop($items);
        array_push($items, str_replace('</div>', '', $last));
        array_push($items, t('Extra line items field: @name', array('@name' => $extra_line_items_field ? $instances[$extra_line_items_field]['label'] : t('None defined'))));
        array_push($items, t('Skip customization on add to cart form: @value', array('@vakue' => $skip_customization_on_add_to_cart ? t('Yes') : t('No'))) . '</div>');
        $form['fields'][$field_name]['settings_summary']['#markup'] = implode('<br />', $items);
      }

      // Add form element for extra line items field configuration.
      if (!empty($form['fields'][$field_name]['format']['settings_edit_form']['settings'])) {
        $field_settings = $instances[$field_name]['display'][$form['#view_mode']]['settings'];
        if (!empty($form_state['values']['fields'][$field_name]['settings_edit_form']['settings']['extra_line_items_field'])) {
          $field_settings = $form_state['values']['fields'][$field_name]['settings_edit_form']['settings'];
        }
        $form['fields'][$field_name]['format']['settings_edit_form']['settings'] += commerce_custom_product_field_formatter_settings_form_element($field_settings, $form['#entity_type'], $form['#bundle']);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_settings_form_alter().
 *
 * Ctools content type support for this field.
 */
function commerce_custom_product_field_formatter_settings_form_alter(&$settings_form, &$context) {
  $context_name = key($context['form']['context']['#options']);
  if (!empty($context['form']['context']['#default_value'])) {
    $context_name = $context['form']['context']['#default_value'];
  }
  $pane_context = (isset($context['form_state']['contexts'][$context_name])) ? $context['form_state']['contexts'][$context_name] : NULL;
  $entity_type = end($pane_context->type);
  $field_settings = $context['instance']['display'][$context['view_mode']]['settings'];
  $settings_form += commerce_custom_product_field_formatter_settings_form_element($field_settings, $entity_type);
}

/**
 * Returns extra line item types field settings element.
 *
 * @param array $field_settings
 *   The current field settings.
 * @param string $entity_type
 *   The entity type to check.
 * @param string|NULL $bundle
 *   The bundle to check.
 *
 * @return array
 *   The configuration element(s).
 */
function commerce_custom_product_field_formatter_settings_form_element($field_settings, $entity_type, $bundle = NULL) {
  $element = array();
  // Check if we have both product reference and line item type reference
  // fields.
  $field_options = commerce_custom_product_get_field_options($entity_type, $bundle);
  if (!empty($field_options['line_item_type_ref_fields']) && !empty($field_options['product_ref_fields'])) {
    foreach ($field_options['product_ref_fields'] as $field_name) {
      $extra_line_items_field = NULL;;
      if (!empty($field_settings['extra_line_items_field'])) {
        $extra_line_items_field = $field_settings['extra_line_items_field'];
      }
      $element['extra_line_items_field'] = array(
        '#type' => 'select',
        '#title' => t('Extra line item types field'),
        '#description' => t('Choose a field that should be used as a source for configuration for any additional line items that should be added to the order with this product.'),
        '#default_value' => $extra_line_items_field,
        '#options' => array(0 => t('- None -')) + $field_options['line_item_type_ref_fields'],
        '#attributes' => array('class' => array('extra-line-items-field')),
      );
      $element['skip_customization_on_add_to_cart'] = array(
        '#type' => 'checkbox',
        '#title' => t('Skip customization on add to cart'),
        '#description' => t('If enabled the customization form is not show in the Add to Cart form but can be done in the checkout.'),
        '#default_value' => !empty($field_settings['skip_customization_on_add_to_cart']),
        '#states' => array(
          'invisible' => array(
            '.extra-line-items-field' => array('value' => '0'),
          ),
        ),
      );

    }
  }
  return $element;
}

/**
 * Implements hook_commerce_checkout_page_info().
 */
function commerce_custom_product_commerce_checkout_page_info() {
  $checkout_pages = array();

  // Define a page where the customizing of products can be handled.
  $checkout_pages['customizing'] = array(
    'name' => t('Customization'),
    'title' => t('Customize products'),
    'help' => t('Customize customizable products.'),
    'weight' => -20,
    'buttons' => TRUE,
    'status_cart' => TRUE,
  );

  return $checkout_pages;
}

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_custom_product_commerce_checkout_pane_info() {
  return array(
    'customizing_pane' => array(
      'title' => t('Product customization'),
      'name' => t('Product customization'),
      'page' => 'customizing',
      'review' => FALSE,
      'base' => 'commerce_custom_product_customizing_pane',
      'file' => 'commerce_custom_product.panes.inc',
      'weight' => 0,
    ),
  );
}

/**
 * Implements hook_commerce_checkout_router().
 */
function commerce_custom_product_commerce_checkout_router($order, $checkout_page) {
  // Update the order status to reflect the next checkout page.
  if ($checkout_page['page_id'] == 'customizing' && variable_get('commerce_custom_product_customizing_skip', TRUE) && !commerce_custom_product_order_get_existing_extra_line_items($order)) {
    $order = commerce_order_status_update($order, 'checkout_' . $checkout_page['next_page'], FALSE, NULL, t('Customer was redirected to next page since there are no products to customize.'));
    drupal_goto('checkout/' . $order->order_id . '/' . $checkout_page['next_page']);
  }
}

/**
 * Special handling for the customizing_review view mode of extra line item.
 */
function commerce_custom_product_preprocess_entity(&$vars) {
  // Hide the title of customizing line items in the reviewing view mode.
  if ($vars['view_mode'] == 'customizing_review' && isset($vars['commerce_line_item']->data['context']['commerce_custom_product'])) {
    // This hides the title - even though it could have some other sideeffects
    $vars['page'] = TRUE;
  }
}