<?php

/**
 * @file
 * Adds features to support the creation of customizable products.
 */


/**
 * Implements hook_menu().
 */
function commerce_custom_product_menu() {
  $items = array();

  $items['admin/commerce/config/line-items/add-product-line-item-type'] = array(
    'title' => 'Add a product line item type',
    'description' => 'Create a new customizable product line item type.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_custom_product_line_item_type_form', array('type' => '', 'name' => '')),
    'access arguments' => array('administer line item types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/commerce_custom_product.admin.inc',
  );

  // Add delete links for custom product line item types that can be deleted.
  foreach (commerce_custom_product_commerce_line_item_type_info() as $type => $line_item_type) {
    // Convert underscores to hyphens for the menu item argument.
    $type_arg = strtr($type, '_', '-');

    $items['admin/commerce/config/line-items/' . $type_arg . '/edit'] = array(
      'title' => 'Edit',
      'description' => 'Edit the custom product line item type.',
      'page callback' => 'commerce_custom_product_line_item_type_edit',
      'page arguments' => array($type),
      'access arguments' => array('administer line item types'),
      'type' => MENU_LOCAL_TASK,
      'context' => MENU_CONTEXT_INLINE,
      'weight' => 5,
      'file' => 'includes/commerce_custom_product.admin.inc',
    );

    $items['admin/commerce/config/line-items/' . $type_arg . '/delete'] = array(
      'title' => 'Delete',
      'description' => 'Delete the custom product line item type.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('commerce_custom_product_line_item_type_delete_form', $type),
      'access callback' => 'commerce_custom_product_line_item_type_delete_access',
      'access arguments' => array($type),
      'type' => MENU_LOCAL_TASK,
      'context' => MENU_CONTEXT_INLINE,
      'weight' => 10,
      'file' => 'includes/commerce_custom_product.admin.inc',
    );
  }

  return $items;
}

/**
 * Determines access to a delete form for the given line item type.
 */
function commerce_custom_product_line_item_type_delete_access($type) {
  // Load the line item type.
  $line_item_type = commerce_line_item_type_load($type);

  // Look for any line items of this type.
  $query = new EntityFieldQuery();

  $query
    ->entityCondition('entity_type', 'commerce_line_item', '=')
    ->entityCondition('bundle', $type, '=')
    ->count();

  // If we found at least one, return FALSE to prevent deletion of this line
  // item type.
  if ($query->execute() > 0) {
    return FALSE;
  }

  return user_access('administer line item types');
}

/**
 * Implements hook_help().
 */
function commerce_custom_product_help($path, $arg) {
  if ($path == 'admin/commerce/config/line-items') {
    return '<p>' . t('Add as many product line item types as you need to support the types of customizable products on your site. You must then change the Add to Cart form display formatter settings of a product reference field to use the new line item type. Any fields attached to the line item type marked to appear on the Add to Cart form will then appear when that form is rendered.') . '</p><p>' . t('Once a line item has been saved for the custom line item type (such as a product being added to the cart), the line item type can no longer be deleted unless you first delete all related line items.') . '</p>';
  }
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function commerce_custom_product_commerce_line_item_type_info() {
  $line_item_types = array();

  // Look for product line item types currently defined in the database.
  $db_types = commerce_custom_product_line_item_types();

  if (!empty($db_types)) {
    foreach ($db_types as $type => $line_item_type) {
      $line_item_types[$type] = array(
        'name' => check_plain($line_item_type['name']),
        'description' => t('A customizable product line item type.'),
        'product' => TRUE,
        'add_form_submit_value' => t('Add product'),
        'base' => 'commerce_product_line_item',
      );
    }
  }

  return $line_item_types;
}

/**
 * Returns an array of all available customizable product line item types.
 */
function commerce_custom_product_line_item_types() {
  return db_query('SELECT * FROM {commerce_product_line_item_type}')->fetchAllAssoc('type', PDO::FETCH_ASSOC);
}

/**
 * Saves a customizable product line item type.
 *
 * @param $line_item_type
 *   The full line item type info array to save.
 * @param $configure
 *   Boolean indicating whether or not line item type configuration should be
 *   performed in the event of a new line item type being saved.
 * @param $skip_rebuild
 *   Boolean indicating whether or not this save should result in the menu being
 *   rebuilt; defaults to FALSE. This is useful when you intend to perform many
 *   saves at once, as menu rebuilding is very costly to performance.
 *
 * @return
 *   The return value of the call to drupal_write_record() to save the line item
 *   type, either FALSE on failure or SAVED_NEW or SAVED_UPDATED indicating the
 *   type of query performed to save the line item type.
 */
function commerce_custom_product_line_item_type_save($line_item_type, $configure = TRUE, $skip_rebuild = FALSE) {
  $op = drupal_write_record('commerce_product_line_item_type', $line_item_type, commerce_line_item_type_load($line_item_type['type']) ? 'type' : array());
  commerce_line_item_types_reset();

  if ($op == SAVED_NEW) {
    // Notify the field API that a new bundle has been created.
    field_attach_create_bundle('commerce_line_item', $line_item_type['type']);

    // Load the full line item type array.
    $line_item_type = commerce_line_item_type_load($line_item_type['type']);

    // Configure the new line item type with default fields.
    if ($configure) {
      commerce_line_item_configure_line_item_type($line_item_type);
    }

    // Notify other modules that a new line item type has been created.
    module_invoke_all('commerce_custom_product_line_item_type_insert', $line_item_type, $skip_rebuild);
  }
  elseif ($op == SAVED_UPDATED) {
    // Notify other modules that an existing line item type has been updated.
    module_invoke_all('commerce_custom_product_line_item_type_update', $line_item_type, $skip_rebuild);
  }

  if (!$skip_rebuild) {
    variable_set('menu_rebuild_needed', TRUE);
  }

  return $op;
}

/**
 * Deletes a customizable product line item type.
 *
 * @param $type
 *   The machine-name of the line item type to delete.
 */
function commerce_custom_product_line_item_type_delete($type) {
  // Load the full line item type.
  $line_item_type = commerce_line_item_type_load($type);

  db_delete('commerce_product_line_item_type')
    ->condition('type', $type)
    ->execute();

  commerce_line_item_types_reset();

  // Notify other modules that this bundle / line item type has been deleted.
  field_attach_delete_bundle('commerce_line_item', $line_item_type['type']);
  module_invoke_all('commerce_custom_product_line_item_type_delete', $line_item_type);

  variable_set('menu_rebuild_needed', TRUE);
}

/**
 * Implements hook_field_info().
 */
function commerce_custom_product_field_info() {
  return array(
    'commerce_custom_product_line_item_type_reference' => array(
      'label' => t('Line item type reference'),
      'description' => t('This field stores the ID of a related line item type.'),
      'settings' => array(),
      'instance_settings' => array(),
      'default_widget' => 'commerce_custom_product_line_item_type_reference_select',
      'default_formatter' => NULL,
    ),
  );
}

/**
 * Implements hook_field_validate().
 */
function commerce_custom_product_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    if (!empty($item['target_id'])) {
      $type = commerce_line_item_type_load($item['target_id']);
      if (!$type || !$type['product']) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'commerce_custom_product_line_item_type_reference_invalid',
          'message' => t('%name: Invalid line item type referenced.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_widget_info().
 */
function commerce_custom_product_field_widget_info() {
  $widgets = array();

  $widgets['commerce_custom_product_line_item_type_reference_select'] = array(
    'label' => t('Select list'),
    'description' => t('Select referencable line item type from a drop-down.'),
    'field types' => array('commerce_custom_product_line_item_type_reference'),
    'settings' => array(),
    'behaviors' => array(
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );

  return $widgets;
}

/**
 * Implements hook_field_widget_form().
 */
function commerce_custom_product_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // Define the autocomplete textfield for products.
  if ($instance['widget']['type'] == 'commerce_custom_product_line_item_type_reference_select') {
    $line_items_types = array_filter(
      commerce_line_item_types(),
      function ($item) { return $item['product']; }
    );

    $options = array(NULL => '- ' . t('None') . ' -');
    foreach ($line_items_types as $line_items_type) {
      $options[$line_items_type['type']] = $line_items_type['name'];
    }

    return $element + array(
      'target_id' => array(
        '#type' => 'select',
        '#default_value' => isset($items[$delta]['target_id']) ? $items[$delta]['target_id'] : NULL,
        '#options' => $options,
      ),
      'use_multi' => array(
        '#type' => 'checkbox',
        '#title' => t('One line item per product item'),
        '#default_value' => isset($items[$delta]['use_multi']) ? $items[$delta]['use_multi'] : 0,
      ),
    );
  }
}

/**
 * Implements hook_field_is_empty().
 */
function commerce_custom_product_field_is_empty($item, $field) {
  return empty($item['target_id']);
}

/**
 * Implements hook_field_formatter_info().
 */
function commerce_custom_product_field_formatter_info() {
  return array(
    'commerce_custom_product_add_to_cart_form' => array(
      'label' => t('Add to Cart form with per-product line items'),
      'description' => t('Display an Add to Cart form for the referenced product allowing to configure line items on a per-product basis.'),
      'field types' => array('commerce_product_reference', 'entityreference'),
      'settings' => array(
        'show_quantity' => FALSE,
        'default_quantity' => 1,
        'combine' => TRUE,
        'show_single_product_attributes' => FALSE,
        'line_item_type_configuration' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function commerce_custom_product_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = array_merge(field_info_formatter_settings($display['type']), $display['settings']);

  $element = array();

  if ($display['type'] == 'commerce_custom_product_add_to_cart_form') {
    $element['show_quantity'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display a textfield quantity widget on the add to cart form.'),
      '#default_value' => $settings['show_quantity'],
    );

    $element['default_quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Default quantity'),
      '#default_value' => $settings['default_quantity'] <= 0 ? 1 : $settings['default_quantity'],
      '#size' => 16,
    );

    $element['combine'] = array(
      '#type' => 'checkbox',
      '#title' => t('Attempt to combine like products on the same line item in the cart.'),
      '#description' => t('The line item type, referenced product, and data from fields exposed on the Add to Cart form must all match to combine.'),
      '#default_value' => $settings['combine'],
    );

    $element['show_single_product_attributes'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show attribute widgets even if the Add to Cart form only represents one product.'),
      '#description' => t('If enabled, attribute widgets will be shown on the form with the only available options selected.'),
      '#default_value' => $settings['show_single_product_attributes'],
    );

    // Add a conditionally visible line item type configuration element.
    $all_fields = array_filter(
      field_info_instances($instance['entity_type'], $instance['bundle']),
      function ($item) {
        $field = field_info_field($item['field_name']);
        return $field['type'] == 'commerce_custom_product_line_item_type_reference' && empty($item['deleted']);
      }
    );

    $options = array();
    foreach ($all_fields as $field) {
      $options[$field['field_name']] = $field['label'];
    }

    $element['line_item_type_configuration'] = array(
      '#type' => 'select',
      '#title' => t('Line item type configuration field'),
      '#options' => $options,
      '#default_value' => $settings['line_item_type_configuration'],
    );
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function commerce_custom_product_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = array_merge(field_info_formatter_settings($display['type']), $display['settings']);

  $summary = array();

  if ($display['type'] == 'commerce_custom_product_add_to_cart_form') {
    $config_field = field_info_instance($instance['entity_type'], $settings['line_item_type_configuration'], $instance['bundle']);
    $summary = array(
      t('Quantity widget: !status', array('!status' => !empty($settings['show_quantity']) ? t('Enabled') : t('Disabled'))),
      t('Default quantity: @quantity', array('@quantity' => $settings['default_quantity'])),
      t('Combine like items: !status', array('!status' => !empty($settings['combine']) ? t('Enabled') : t('Disabled'))),
      t('!visibility attributes on single product forms.', array('!visibility' => !empty($settings['show_single_product_attributes']) ? t('Showing') : t('Hiding'))),
      t('Add to Cart line item type configuration: @field', array('@field' => $config_field['label'])),
    );
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function commerce_custom_product_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $settings = array_merge(field_info_formatter_settings($display['type']), $display['settings']);
  $result = array();

  if ($display['type'] == 'commerce_custom_product_add_to_cart_form') {
    // Collect the list of product IDs.
    $product_ids = array();

    foreach ($items as $delta => $item) {
      if (isset($item['product_id'])) {
        $product_ids[] = $item['product_id'];
      }
      elseif (module_exists('entityreference') && isset($item['target_id'])) {
        $product_ids[] = $item['target_id'];
      }
    }

    // Load the referenced products.
    $products = commerce_product_load_multiple($product_ids);

    // Check to ensure products are referenced, before returning results.
    if (!empty($products)) {
      $line_items = array();
      $types = field_get_items($entity_type, $entity, $settings['line_item_type_configuration']);

      if (empty($types)) {
        $line_item = commerce_product_line_item_new(commerce_product_reference_default_product($products), $settings['default_quantity'], 0, array(), 'product');
        $line_item->data['context']['product_ids'] = array_keys($products);
        $line_item->data['context']['add_to_cart_combine'] = !empty($settings['combine']);
        $line_item->data['context']['show_single_product_attributes'] = !empty($settings['show_single_product_attributes']);
        $line_items[] = $line_item;
      }
      else {
        foreach ($types as $type) {
          // TODO create more if use_multi.
          $line_item = commerce_product_line_item_new(commerce_product_reference_default_product($products), $settings['default_quantity'], 0, array(), $type['target_ids']);
          $line_item->data['context']['product_ids'] = array_keys($products);
          $line_item->data['context']['add_to_cart_combine'] = !empty($settings['combine']);
          $line_item->data['context']['show_single_product_attributes'] = !empty($settings['show_single_product_attributes']);
          $line_items[] = $line_item;
        }
      }

      $result[] = array(
        '#arguments' => array(
          'form_id' => commerce_cart_add_to_cart_form_id($product_ids),
          'line_items' => $line_items,
          'show_quantity' => $settings['show_quantity'],
        ),
      );
    }
  }

  return $result;
}

/**
 * Builds an appropriate cart form ID based on the products on the form.
 */
function commerce_custom_product_add_to_cart_form_id($product_ids) {
  // Make sure the length of the form id is limited.
  $data = implode('_', $product_ids);

  if (strlen($data) > 50) {
    $data = drupal_hash_base64($data);
  }

  return 'commerce_custom_product_add_to_cart_form_' . $data;
}

/**
 * Builds an Add to Cart form for a set of products.
 */
function commerce_custom_add_to_cart_form($form, &$form_state, $line_items, $show_quantity = FALSE, $context = array()) {
  commerce_cart_add_to_cart_form($form, $form_state, $line_items[0], $show_quantity, $context);
  // TODO handle line items.
}
